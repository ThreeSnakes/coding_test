# NO.11052 붕어빵 판매하기.#

**붕어빵 판매하기.**

**문제**
> 강남역에서 붕어빵 장사를 하고 있는 해빈이는 지금 붕어빵이 N개 남았다.

> 해빈이는 적절히 붕어빵 세트 메뉴를 구성해서 붕어빵을 팔아서 얻을 수 있는 수익을 최대로 만드려고 한다. 붕어빵 세트 메뉴는 붕어빵을 묶어서 파는 것을 의미하고, 세트 메뉴의 가격은 이미 정해져 있다.

> 붕어빵 i개로 이루어진 세트 메뉴의 가격은 Pi 원이다.

> 붕어빵이 4개 남아 있고, 1개 팔 때의 가격이 1, 2개는 5, 3개는 6, 4개는 7인 경우에 해빈이가 얻을 수 있는 최대 수익은 10원이다. 2개, 2개로 붕어빵을 팔면 되기 때문이다.

> 1개 팔 때의 가격이 5, 2개는 2, 3개는 8, 4개는 10 인 경우에는 20이 된다. 1개, 1개, 1개, 1개로 붕어빵을 팔면 되기 때문이다.

> 마지막으로, 1개 팔 때의 가격이 3, 2개는 5, 3개는 15, 4개는 16인 경우에는 정답은 18이다. 붕어빵을 3개, 1개로 팔면 되기 때문이다.

> 세트 메뉴의 가격이 주어졌을 때, 해빈이가 얻을 수 있는 최대 수익을 구하는 프로그램을 작성하시오.

**입력**
> 첫째 줄에 해빈이가 가지고 있는 붕어빵의 개수 N이 주어진다. (1 ≤ N ≤ 1,000)

> 둘째 줄에는 Pi가 P1부터 PN까지 순서대로 주어진다. (1 ≤ Pi ≤ 10,000)

**출력**
> 해빈이가 얻을 수 있는 최대 수익을 출력한다.

**내가 푼 방법.**
> 1개가 남았을 떄는 1개 값을 출력하면 되고,

> 2개가 남았을 떄는 2개를 같이 팔았을 떄와 1개씩 2번 팔았을 때를 비교해서 큰 값을 리턴해주면 된다.

> 마찬가지로 3개 이상일 즉 N개 일때는

> N개를 한꺼번에 판매 했을 떄와 여러번 잘라서 팔았을 때를 비교하면 된다.

> 여러번 잘라서 팔았을 떄를 구하는 방법은 다음과 같이 구하였다.

> 일단 배열을 만들어서 n개 팔때 가장 많이 받을 수 있는 금액을 저장한다. (max_price) 여기서 1개 팔았을때와 2개 팔았을때는

> 쉽게 구할 수 있으니 바로 넣어주고, 3개 이상부터 구하는데 즉 max_price[3] 을 구하는 것이다. ( 헷갈릴까봐 1부터 값을 넣었다. )

> 3개를 잘라서 팔수 있는 방법은 3가지 이다. 1 + 2, 2 + 1 즉 2가지 이다. 근데 이건 순서만 바뀌었지 같은 방법이다.

> 그러므 중복 되는 값을 어떻게 제거 했냐면 3을 2로 나눠  버린다. 그러면 1이 나온다. 

> max_price[3-1] + max_price[1] 을 하면 된다. 이게 숫자가 3이어서 이상한데 4라고 생각해보자.

> 4개를 잘라서 팔수 있는 방법은 1 + 3 , 2 + 2, 3 + 1 즉 3가지이다.근데 중복되는거 빼면 2가지 인데.

> 4/2 를 하면 2가 나온다. 이것을 for문으로 돌리면

> max_price[4-1] + max_price[1]  값이 나올 것이고, 그다음 max_price[4-2] + max_price[2] 값이 나올 것이다.

> 즉 중복된는 계산을 안해도 되고 이 값중 큰값을 price[n] 과 비교해서 큰값을 max_price[n+1] 에다 넣어 주면된다.

> 말로 설명하니깐 더 어려운데 그냥 코드 보자. 코드 보면 이해 된다. 


``` C
#include <stdio.h>

#define MAX_CNT 1000
#define MAX(x,y) ((x > y) ? x:y)

int main(void) {
	int _input_cnt, i, j;
	int price[MAX_CNT];
	int max_price[MAX_CNT];
	int sum_max;

	
	scanf("%d", &_input_cnt);
	
	for(i = 0; i < _input_cnt; i++) {
		scanf("%d", &price[i]);		
	}
	
	if(_input_cnt == 1) {
		printf("%d", price[0]);
	} else if(_input_cnt == 2) {
		printf("%d", MAX(price[1], price[0] + price[0]));	
	} else {
		max_price[1] = price[0];
		max_price[2] = MAX(price[1], price[0] + price[0]);

		for(i = 3; i <= _input_cnt; i++) {
			sum_max = 0;
			for(j = 1; j <= (i/2); j++) {
				sum_max = MAX(sum_max, (max_price[i - j] + max_price[j]));
				//printf("sum_max => %d\n", sum_max);
			}

			max_price[i] = MAX(price[i-1], sum_max);
		}
		//printf("\n result => ");
		// for(i = 0; i <= _input_cnt; i++) {
		// 	printf("%d\t", max_price[i]);		
		// }

		printf("%d", max_price[_input_cnt]);	
	}
	
	return 0;
}
```

| No      | ID        | Quest.NO | Result        | Memory Use | Time  | lanaguage | Code Length |
|---------|-----------|----------|---------------|------------|-------|-----------|-------------|
| 6023579 | select995 | 11052    | SUCCESS!!     | 1116 KB    | 0 MS  |     C     | 795 B       |
| 6023555 | select995 | 11052    | 출력 초과       | -          | -     |   C       | 796 B       |



> 출력 초과는 모르고 콘솔로그 몇개 안지웠다  -_-;; 

> 맥에다가 C 깔기 귀찮아서 구름IDE 로 했는데 결과가 바로 나오진 않아도 그냥 그냥 쓸만하다. C를 깔아야 하나 그냥 해야 하나 고민이네..