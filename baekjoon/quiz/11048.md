#[NO.11048 이동 하기](https://www.acmicpc.net/problem/11048)#

**이동 하기.**

**문제**
> 준규는 N×M 크기의 미로에 갇혀있다. 미로는 1×1크기의 방으로 나누어져 있고, 각 방에는 사탕이 놓여져 있다. 미로의 가장 왼쪽 윗 방은 (1, 1)이고, 가장 오른쪽 아랫 방은 (N, M)이다.

> 준규는 현재 (1, 1)에 있고, (N, M)으로 이동하려고 한다. 준규가 (i, j)에 있으면, (i+1, j), (i, j+1), (i+1, j+1)로 이동할 수 있고, 각 방을 방문할 때마다 방에 놓여져있는 사탕을 모두 가져갈 수 있다. 또, 미로 밖으로 나갈 수는 없다.

> 준규가 (N, M)으로 이동할 때, 가져올 수 있는 사탕 개수의 최대값을 구하시오.

**입력**
> 첫째 줄에 미로의 크기 N, M이 주어진다. (1 ≤ N, M ≤ 1,000)

> 둘째 줄부터 N개 줄에는 총 M개의 숫자가 주어지며, i번째 줄의 j번째 숫자는 (i, j)에 놓여져 있는 사탕의 개수이다. 사탕의 개수는 0보다 크거나 같고, 100보다 작거나 같다.

**출력**
> 첫째 줄에 준규가 (N, M)으로 이동할 때, 가져올 수 있는 사탕 개수를 출력한다.

**내가 푼 방법.**
> 이 문제는 쉽게 풀었다.

> 일단 미로의 크기를 입력 받는다. (bucket[][]으로 받았다. )

> 그다음 bucket[0][0] 부터 차례대로 계산 하면 되는 것이다. 

> 일단 첫 행은 오른쪽으로 밖에 이동을 못한다. 이게 왔던 길을 되돌아가는 문제가 아니기 때문에 준규는 무조건 bucket[n-1][m-1]까지 전진 하는 수밖에 없는 것이다.

> 하여튼 첫행은 왼쪽에서 오른쪽으로 칸을 이동 할때마다 더해주면 되는 것이고.

> 첫 열은 마찬가지로 아래로 밖에 이동하지 못한다. 그러면 밑의 칸으로 이동할떄마다 더해 주면 된다.

> 그럼 bucket[1][1] 부터는 계산을 해줘야 한다. 문제에서 보다싶이 bucket[1][1]로 이동 하는 방법은 3가지이다. 

> bucket[0][0], bucket[1][0], bucket[0][1] 에서 이동하는 방법 세가지이다. 그러면 이 세개의 값중에서 가장 큰값을 뽑은 다음에 이동하는 칸의 숫자와 더해주면 

> 이동하는 칸으로 가는 가장 큰 값이 되는 것이다. 

> 이런 식으로 쭉 계산 한다음에 마지막 bucket[n-1][m-1]의 값을 뽑아 주면 된다. 간단하다.!


``` c
#include <stdio.h>

#define MAX_BUCKET_SIZE 1000
#define MAX(x,y) ((x > y) ? x:y)

int main(void) {
	int width, height, i, j;
	int bucket[MAX_BUCKET_SIZE][MAX_BUCKET_SIZE];
		
	scanf("%d", &width);
	scanf("%d", &height);
	
	for(i = 0 ; i < width; i++) {
		for(j = 0; j < height; j++) {
			scanf("%d", &bucket[i][j]);
		}
	}
	
	for (i = 0; i < width; i++ ) {
		for(j = 0; j < height; j++ ) {
			if( i == 0 && j == 0) {
				continue;
			} else {
				if(i == 0 ) {
					bucket[i][j] = bucket[i][j-1] + bucket[i][j];
				} else {
					if(j == 0) {
						bucket[i][j] = bucket[i-1][j] + bucket[i][j];
					} else {
						bucket[i][j] = MAX(bucket[i-1][j], MAX(bucket[i-1][j-1], bucket[i][j-1])) + bucket[i][j];
					}
				}
			}
		}
	}
	
	// for(i = 0 ; i < width; i++) {
	// 	for(j = 0; j < height; j++) {
	// 		printf("%d ", bucket[i][j]);
	// 	}
	// 	printf("\n");
	// }
	
	printf("%d", bucket[width-1][height-1]);
	
	return 0;
}
```

| No      | ID        | Quest.NO | Result        | Memory Use | Time  | lanaguage | Code Length |
|---------|-----------|----------|---------------|------------|-------|-----------|-------------|
| 6094579 | select995 | 11048    | SUCCESS!!     | 5928 KB    | 96 MS |     C     | 973 B       |
| 6094571 | select995 | 11048    | 출력 초과       | -          | -     |   C       | 955 B       |
| 6094503 | select995 | 11048    | 틀렸습니다.      | -          | -     |   C       | 973 B       |



> 허허 처음 틀렸을 떄는 continu에서 조건을 잘못 줬다 -_-;; `( i == 0 && j == 0)` 일떄를 `( i == 0 && j == 1)` 로 썼다.

> 두번쨰는 발견해서 수정하고 다시 제출하는데 log를 안지워서 출력 초과..

> 세번째에서야 맞았다. ㅋㅋㅋ

> 첫번째에 테스트 할떄 테스트 케이스가 모두 정답으로 나와서 당연히 맞겠구나 하고 제출 했는데 

> 역시 테스트는 많이 해봐야 한다. 