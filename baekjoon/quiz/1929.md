#1929번 문제#

**소수 구하기**

> M이상 N이하의 소수를 모두 출력하는 프로그램을 작성하시오.

**입력**
> 첫째 줄에 자연수 M과 N이 빈 칸을 사이에 두고 주어진다. (1≤M≤N≤1,000,000)

**출력**
> 한 줄에 하나씩, 증가하는 순서대로 소수를 출력한다.

``` c
#include<stdio.h>

int main(void) {
	// 기존에 하던 방식으로 구현하면 
	// 시간 초과가 발생해서 문제를 다시 찾아 보았다.
	// 에라토스테네스의 체를 이용하면 쉽게 소수를 구할수 있다.
	// 1...n까지이 수 중에서 소수를 구한다고 한다면.
	// 1은 소수가 아니므로 제외한다.
	// 2는 소수이고 2의 배수는 소수가 아니다. 2의 배수 제외.
	// 3은 소수이고 3의 배수는 소수가 아니다. 3의 배수 제외.
	// 4는 소수가 아니므로 삭제....
	// 이런식으로 n까지 수를 삭제한뒤 남은수가 소수가 되는 것이다.

	int min, max;
	int i, j;
	// 배열은 0부터 시작이어서 쉽게 생각하기 위해서 1000001까지 선언.
	int max_number = 1000001;
	int *bucket;
	
	bucket = (int*)malloc(sizeof(int)*max_number);

	scanf("%d", &min);
	scanf("%d", &max);
	
	for (i = 0; i <= max; i++) {
		bucket[i] = 0;
		if (i == 1) {
			// 1은 소수가 아니므로 체크 안하기 위해서 -1로 할당.
			bucket[i] = -1;
		}
		if (i % 2 == 0 && i != 2) {
			//일단 2의 배수는 소수가 아니므로 체크 안하기 위해서 -1로 할당.
			//2는 소수가 맞으므로 남겨 놓는다.
			bucket[i] = -1;
		}
	}

	for (i = 3; i <= max; i++) {
		if (bucket[i] != -1) {
			for (j = i + i; j <= max; j = j + i) {
				bucket[j] = -1;
			}
		}
	}

	for (min; min <= max; min++) {
		if (min == 1000000) {
			break;
		}

		if (bucket[min] != -1) {
			printf("%d\n", min);
		}

	}
		

	return 0;
}
```

| No      | ID        | Quest.NO | Result   | Memory Use | Time  | lanaguage | Code Length |
|---------|-----------|----------|----------|------------|-------|-----------|-------------|
| 4559996 | select995 | 1929     | SUCCESS  | 4856 KB    | 24 MS | C         | 1583 B      |
| 4559973 | select995 | 1929     | FAIL     |            |       | C         | 1580 B      |
| 4559963 | select995 | 1929     | FAIL     |            |       | C         | 1580 B      |
| 4559961 | select995 | 1929     | FAIL     |            |       | C         | 1537 B      |
| 4559898 | select995 | 1929     | TIME OUT |            |       | C         | 1761 B      |
| 4559308 | select995 | 1929     | TIME OUT |            |       | C         | 547 B       |

> 많이도 틀렸다. 처음 2번의 시간 초과는 기존의 소수 구하는 문제처럼 풀었다가 큰코 다쳤다. 수가 커지니깐 그만큼 반복문으로 돌면서 확인하는 과정에서 시간이 오래 걸렸다. 그래서 이 확인하는 과정을 줄여야 됬는데 검색을 통하니 에라토스테네스의의 체를 이용해서 풀면 된다고 해서 이 방법을 통해서 풀어 봤다. 다음 3번의 틀렸습니다...는 처음 배열을 초기화 해주는데 `max`값을 포함하여 초기화를 해줘야 하는데 포함하지 않고 초기화를 해버려서 마지막 출력할때 `bucket[min] != -1`에서 걸러지지 않아서 자꾸 마지막값도 출력하는 문제였다. 엄한데 체크하다가 자꾸 틀렸습니다. 남발...

> 그리고 중간에 약간 이해가 안되는 부분도 있었다. 처음에 2부터 시작해서 배수를 삭제해주는데 그 수가 커질 때 마다 그 수의 소수 체크는 할 필요가 없을까?란 의문이 생겼다. 만약에 582311이란 숫자부터 시작한다고 가정 했을 때 이 수는 소수인지 아닌지 판별을 과연 에라토스테네스의 체로만 확인이 가능한가라는 의문이 생긴거다. 근데 다시 한번 생각해보니 자연수, 거기다 1부터 시작하니 충분히 걸러지겠다는 생각이 들었다.

> 흠 이번 문제는 너무 쉽게 생각해서 많이 틀린듯 하다.